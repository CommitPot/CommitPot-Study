# 동기와 비동기의 차이 (Blocking VS Non - blocking)

## Sync / Async

> **동기**는 요청과 그 결과가 동시에 일어난다는 뜻이며,
> 다시 말하면, 어떤 객체 또는 함수 내부에서 다른 함수를 호출했을 때 이 **<u>함수의 결과를 호출한 쪽에서 처리</u>**하면 동기입니다.
>
> **비동기**는 요청과 그 결과가 동시에 일어나지 않는다는 뜻이며,
> 동기와 달리 어떤 객체 또는 함수 내부에서 다른 함수를 호출했을 때 이 **<u>함수의 결과를 호출한 쪽에서 처리하지 않으면 비동기</u>**입니다. 

✔️ 동시에 ?
실행되었을 때 값이 반환되기 전까지는 blocking되어 있다는 것을 의미

- 비동기의 경우, blocking되지 않고 이벤트 큐에 넣거나 백그라운드 스레드에게 해당 task를 위임하고 바로 다음 코드를 실행하기 때문에 기대되는 값이 바로 반환되지 않는다.

### Synchronous

작업을 요청한 후 해당 작업의 결과가 나올 때까지 기다린 후 처리하는 것으로 IO 작업에 대한 readiness를 기다림. 특정 IO작업을 하기 위한 준비가 되었는지에 집중하는 것
IO작업 준비에 대한 이벤트의 발생을 기다렸다가 해당 이벤트가 발생하면 그에 따른 적합한 처리를 함.

### Asynchronous

![img](https://velog.velcdn.com/images%2Fdewgang%2Fpost%2F92c26f47-9391-457d-a622-befe2bed7ea1%2Fimage.png)

작업을 요청해놓고 딴 일을 하다가 해당 작업이 완료되면 그 때 완료되었음을 통지받고 그에 따른 작업을 처리하는 것을 말한다. completion을 기다리는 것. 운영체제 단계의 비동기 API를 통해 이루어지며 IO작업이 completion이 되면 그에 적합한 handler를 이용해 처리함

**System call의 완료를 기다리면 sync**
**System call의 완료를 기다리지 않으면 async**

## Blocking vs Non-blocking

### Blocking

IO작업을 처리하기 위해 시스템 함수를 호출함 ( = system call )
그래서 IO작업이 끝나고 데이터를 반환하면 스레드에 걸린 block이 풀림. 애플리케이션 관점에서 보면 아무런 동작도 안하는 것처럼 보이지만 실제로는 커널에서 IO작업을 수행하느라 block되어 있는 것임. 이 부분이 blocking 의 문제점

#### 그럼 Sync vs Blocking ?

작업을 요청한 후 해당 작업의 결과가 나올 때까지 기다린 후 처리하는 것, Blocking은 IO가 끝날 때까지 대기해야 함
즉, 동기화 하기 위해 Blocking하는 것임

### Non-blocking

IO작업을 진행하는 동안 작업을 중단시키지 않는다. 시스템 콜을 하면 커널에서 함수의 진행 상황과 상관없이 결과를 바로 반환한다.